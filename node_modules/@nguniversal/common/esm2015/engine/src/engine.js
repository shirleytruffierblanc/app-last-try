var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ResourceLoader } from '@angular/compiler';
import { NgModuleFactory, CompilerFactory } from '@angular/core';
import { INITIAL_CONFIG, renderModuleFactory, platformDynamicServer } from '@angular/platform-server';
import * as fs from 'fs';
import { FileLoader } from './file-loader';
/**
 * A common rendering engine utility. This abstracts the logic
 * for handling the platformServer compiler, the module cache, and
 * the document loader
 */
export class CommonEngine {
    /**
     * @param {?} moduleOrFactory
     * @param {?=} providers
     */
    constructor(moduleOrFactory, providers = []) {
        this.moduleOrFactory = moduleOrFactory;
        this.providers = providers;
        this.factoryCacheMap = new Map();
        this.templateCache = {};
    }
    /**
     * Return an instance of the platformServer compiler
     * @return {?}
     */
    getCompiler() {
        const /** @type {?} */ compilerFactory = platformDynamicServer().injector.get(CompilerFactory);
        return compilerFactory.createCompiler([
            { providers: [{ provide: ResourceLoader, useClass: FileLoader, deps: [] }] }
        ]);
    }
    /**
     * Render an HTML document for a specific URL with specified
     * render options
     * @param {?} opts
     * @return {?}
     */
    render(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            // if opts.document dosen't exist then opts.documentFilePath must
            const /** @type {?} */ doc = opts.document || (yield this.getDocument(/** @type {?} */ (((opts)).documentFilePath)));
            const /** @type {?} */ extraProviders = [
                ...(opts.providers || []),
                ...(this.providers || []),
                {
                    provide: INITIAL_CONFIG,
                    useValue: {
                        document: doc,
                        url: opts.url
                    }
                }
            ];
            const /** @type {?} */ factory = yield this.getFactory();
            return renderModuleFactory(factory, { extraProviders });
        });
    }
    /**
     * Return the factory for a given engine instance
     * @return {?}
     */
    getFactory() {
        // If module has been compiled AoT
        const /** @type {?} */ moduleOrFactory = this.moduleOrFactory;
        if (moduleOrFactory instanceof NgModuleFactory) {
            return Promise.resolve(moduleOrFactory);
        }
        else {
            // we're in JIT mode
            let /** @type {?} */ moduleFactory = this.factoryCacheMap.get(moduleOrFactory);
            // If module factory is cached
            if (moduleFactory) {
                return Promise.resolve(moduleFactory);
            }
            // Compile the module and cache it
            return this.getCompiler().compileModuleAsync(moduleOrFactory)
                .then((factory) => {
                this.factoryCacheMap.set(moduleOrFactory, factory);
                return factory;
            });
        }
    }
    /**
     * Retrieve the document from the cache or the filesystem
     * @param {?} filePath
     * @return {?}
     */
    getDocument(filePath) {
        const /** @type {?} */ doc = this.templateCache[filePath] = this.templateCache[filePath] ||
            fs.readFileSync(filePath).toString();
        // As  promise so we can change the API later without breaking
        return Promise.resolve(doc);
    }
}
function CommonEngine_tsickle_Closure_declarations() {
    /** @type {?} */
    CommonEngine.prototype.factoryCacheMap;
    /** @type {?} */
    CommonEngine.prototype.templateCache;
    /** @type {?} */
    CommonEngine.prototype.moduleOrFactory;
    /** @type {?} */
    CommonEngine.prototype.providers;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5naW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9jb21tb24vZW5naW5lL3NyYy9lbmdpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2pELE9BQU8sRUFBaUIsZUFBZSxFQUFFLGVBQWUsRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDL0YsT0FBTyxFQUFDLGNBQWMsRUFBRSxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBQ3BHLE9BQU8sS0FBSyxFQUFFLE1BQU0sSUFBSSxDQUFDO0FBRXpCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7Ozs7OztBQVF6QyxNQUFNOzs7OztJQWFKLFlBQW9CLGVBQStDLEVBQy9DLFlBQThCLEVBQUU7UUFEaEMsb0JBQWUsR0FBZixlQUFlLENBQWdDO1FBQy9DLGNBQVMsR0FBVCxTQUFTOytCQUpILElBQUksR0FBRyxFQUFpQzs2QkFDakIsRUFBRTtLQUdLOzs7OztJQVh4RCxXQUFXO1FBQ1QsdUJBQU0sZUFBZSxHQUFvQixxQkFBcUIsRUFBRSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDL0YsTUFBTSxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUM7WUFDcEMsRUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLE9BQU8sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFDLENBQUMsRUFBQztTQUN6RSxDQUFDLENBQUM7S0FDSjs7Ozs7OztJQVlLLE1BQU0sQ0FBQyxJQUFtQjs7O1lBRTlCLHVCQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxLQUFJLE1BQU0sSUFBSSxDQUFDLFdBQVcscUJBQUMsSUFBSSxHQUFFLGdCQUFnQixFQUFXLENBQUEsQ0FBQztZQUN0Rix1QkFBTSxjQUFjLEdBQUc7Z0JBQ3JCLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQztnQkFDekIsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDO2dCQUN6QjtvQkFDRSxPQUFPLEVBQUUsY0FBYztvQkFDdkIsUUFBUSxFQUFFO3dCQUNSLFFBQVEsRUFBRSxHQUFHO3dCQUNiLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztxQkFDZDtpQkFDRjthQUNGLENBQUM7WUFFRix1QkFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDeEMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxFQUFDLGNBQWMsRUFBQyxDQUFDLENBQUM7O0tBQ3ZEOzs7OztJQUdELFVBQVU7O1FBRVIsdUJBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDN0MsRUFBRSxDQUFDLENBQUMsZUFBZSxZQUFZLGVBQWUsQ0FBQyxDQUFDLENBQUM7WUFDL0MsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7U0FDekM7UUFBQyxJQUFJLENBQUMsQ0FBQzs7WUFFTixxQkFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7O1lBRzlELEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xCLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3ZDOztZQUdELE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDO2lCQUMxRCxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNuRCxNQUFNLENBQUMsT0FBTyxDQUFDO2FBQ2hCLENBQUMsQ0FBQztTQUNOO0tBQ0Y7Ozs7OztJQUdPLFdBQVcsQ0FBQyxRQUFnQjtRQUNsQyx1QkFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztZQUN2RSxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDOztRQUdyQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Q0FFL0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7UmVzb3VyY2VMb2FkZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcbmltcG9ydCB7Q29tcGlsZXIsIFR5cGUsIE5nTW9kdWxlRmFjdG9yeSwgQ29tcGlsZXJGYWN0b3J5LCBTdGF0aWNQcm92aWRlcn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lOSVRJQUxfQ09ORklHLCByZW5kZXJNb2R1bGVGYWN0b3J5LCBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXJ9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLXNlcnZlcic7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB7RmlsZUxvYWRlcn0gZnJvbSAnLi9maWxlLWxvYWRlcic7XG5pbXBvcnQge1JlbmRlck9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogQSBjb21tb24gcmVuZGVyaW5nIGVuZ2luZSB1dGlsaXR5LiBUaGlzIGFic3RyYWN0cyB0aGUgbG9naWNcbiAqIGZvciBoYW5kbGluZyB0aGUgcGxhdGZvcm1TZXJ2ZXIgY29tcGlsZXIsIHRoZSBtb2R1bGUgY2FjaGUsIGFuZFxuICogdGhlIGRvY3VtZW50IGxvYWRlclxuICovXG5leHBvcnQgY2xhc3MgQ29tbW9uRW5naW5lIHtcblxuICAvKiogUmV0dXJuIGFuIGluc3RhbmNlIG9mIHRoZSBwbGF0Zm9ybVNlcnZlciBjb21waWxlciAqL1xuICBnZXRDb21waWxlcigpOiBDb21waWxlciB7XG4gICAgY29uc3QgY29tcGlsZXJGYWN0b3J5OiBDb21waWxlckZhY3RvcnkgPSBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIoKS5pbmplY3Rvci5nZXQoQ29tcGlsZXJGYWN0b3J5KTtcbiAgICByZXR1cm4gY29tcGlsZXJGYWN0b3J5LmNyZWF0ZUNvbXBpbGVyKFtcbiAgICAgIHtwcm92aWRlcnM6IFt7cHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBGaWxlTG9hZGVyLCBkZXBzOiBbXX1dfVxuICAgIF0pO1xuICB9XG5cbiAgcHJpdmF0ZSBmYWN0b3J5Q2FjaGVNYXAgPSBuZXcgTWFwPFR5cGU8e30+LCBOZ01vZHVsZUZhY3Rvcnk8e30+PigpO1xuICBwcml2YXRlIHRlbXBsYXRlQ2FjaGU6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2R1bGVPckZhY3Rvcnk6IFR5cGU8e30+IHwgTmdNb2R1bGVGYWN0b3J5PHt9PixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcm92aWRlcnM6IFN0YXRpY1Byb3ZpZGVyW10gPSBbXSkge31cblxuICAvKipcbiAgICogUmVuZGVyIGFuIEhUTUwgZG9jdW1lbnQgZm9yIGEgc3BlY2lmaWMgVVJMIHdpdGggc3BlY2lmaWVkXG4gICAqIHJlbmRlciBvcHRpb25zXG4gICAqL1xuICBhc3luYyByZW5kZXIob3B0czogUmVuZGVyT3B0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gaWYgb3B0cy5kb2N1bWVudCBkb3Nlbid0IGV4aXN0IHRoZW4gb3B0cy5kb2N1bWVudEZpbGVQYXRoIG11c3RcbiAgICBjb25zdCBkb2MgPSBvcHRzLmRvY3VtZW50IHx8IGF3YWl0IHRoaXMuZ2V0RG9jdW1lbnQob3B0cyEuZG9jdW1lbnRGaWxlUGF0aCBhcyBzdHJpbmcpO1xuICAgIGNvbnN0IGV4dHJhUHJvdmlkZXJzID0gW1xuICAgICAgLi4uKG9wdHMucHJvdmlkZXJzIHx8IFtdKSxcbiAgICAgIC4uLih0aGlzLnByb3ZpZGVycyB8fCBbXSksXG4gICAgICB7XG4gICAgICAgIHByb3ZpZGU6IElOSVRJQUxfQ09ORklHLFxuICAgICAgICB1c2VWYWx1ZToge1xuICAgICAgICAgIGRvY3VtZW50OiBkb2MsXG4gICAgICAgICAgdXJsOiBvcHRzLnVybFxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcblxuICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCB0aGlzLmdldEZhY3RvcnkoKTtcbiAgICByZXR1cm4gcmVuZGVyTW9kdWxlRmFjdG9yeShmYWN0b3J5LCB7ZXh0cmFQcm92aWRlcnN9KTtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gdGhlIGZhY3RvcnkgZm9yIGEgZ2l2ZW4gZW5naW5lIGluc3RhbmNlICovXG4gIGdldEZhY3RvcnkoKTogUHJvbWlzZTxOZ01vZHVsZUZhY3Rvcnk8e30+PiB7XG4gICAgLy8gSWYgbW9kdWxlIGhhcyBiZWVuIGNvbXBpbGVkIEFvVFxuICAgIGNvbnN0IG1vZHVsZU9yRmFjdG9yeSA9IHRoaXMubW9kdWxlT3JGYWN0b3J5O1xuICAgIGlmIChtb2R1bGVPckZhY3RvcnkgaW5zdGFuY2VvZiBOZ01vZHVsZUZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobW9kdWxlT3JGYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UncmUgaW4gSklUIG1vZGVcbiAgICAgIGxldCBtb2R1bGVGYWN0b3J5ID0gdGhpcy5mYWN0b3J5Q2FjaGVNYXAuZ2V0KG1vZHVsZU9yRmFjdG9yeSk7XG5cbiAgICAgIC8vIElmIG1vZHVsZSBmYWN0b3J5IGlzIGNhY2hlZFxuICAgICAgaWYgKG1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGVGYWN0b3J5KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGlsZSB0aGUgbW9kdWxlIGFuZCBjYWNoZSBpdFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGlsZXIoKS5jb21waWxlTW9kdWxlQXN5bmMobW9kdWxlT3JGYWN0b3J5KVxuICAgICAgICAudGhlbigoZmFjdG9yeSkgPT4ge1xuICAgICAgICAgIHRoaXMuZmFjdG9yeUNhY2hlTWFwLnNldChtb2R1bGVPckZhY3RvcnksIGZhY3RvcnkpO1xuICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogUmV0cmlldmUgdGhlIGRvY3VtZW50IGZyb20gdGhlIGNhY2hlIG9yIHRoZSBmaWxlc3lzdGVtICovXG4gIHByaXZhdGUgZ2V0RG9jdW1lbnQoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZG9jID0gdGhpcy50ZW1wbGF0ZUNhY2hlW2ZpbGVQYXRoXSA9IHRoaXMudGVtcGxhdGVDYWNoZVtmaWxlUGF0aF0gfHxcbiAgICBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgpLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBBcyAgcHJvbWlzZSBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBBUEkgbGF0ZXIgd2l0aG91dCBicmVha2luZ1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZG9jKTtcbiAgfVxufVxuIl19